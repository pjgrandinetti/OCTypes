Fixing Nested Function Parsing and Evaluation Issue

Diagnosis
---------
The expression `conj(sqrt(9+16*I))` failed because the parserâ€™s function-argument list rule (`explist`) did not propagate the inner expression to the outer function node, and the evaluator lacked a case for the `conj` function and proper complex math calls for `sqrt`. While the grammar supports nesting and precedence, these two bugs prevented correct AST construction and evaluation for nested single-argument functions.

Required Changes
----------------

1. Parser Grammar (OCComplexParser.y):
   - Update `explist` rule to pass through the expression node:
     ```yacc
     explist
         : exp { $$ = $1; }
         ;
     ```
   - Ensure the function call rule attaches `explist` to the function node:
     ```yacc
     exp
         : FUNC '(' explist ')' { $$ = ComplexNodeCreateFunction($1, $3); }
         ;
     ```

2. Scanner (OCComplexScanner.l):
   - Confirm inclusion of `conj` in the function token rules:
     ```lex
     "conj" { ocpclval.fn = BM_conj; return FUNC; }
     ```
   - (Optional) Accept lowercase `i` for the imaginary unit:
     ```lex
     [iI]   { ocpclval.d = I; return NUMBER; }
     ```

3. Evaluation Logic (OCMath.c):
   - Include `<complex.h>` for complex routines.
   - In `ComplexNodeEvaluate` (or `builtInMathFunction`), add cases:
     ```c
     case BM_sqrt:  return csqrt(arg);
     case BM_conj:  return conj(arg);
     case BM_creal: return creal(arg) + 0.0*I;
     case BM_cimag: return cimag(arg) * I;
     case BM_carg:  return cargument(arg) + 0.0*I;
     // Ensure other functions use complex variants: cexp, clog, csin, ccos, etc.
     ```

Revised Code Snippets
---------------------
**Grammar (OCComplexParser.y):**
```yacc
explist
    : exp { $$ = $1; }
    ;

exp
    : FUNC '(' explist ')' { $$ = ComplexNodeCreateFunction($1, $3); }
    | /* other rules */
    ;
```

**Evaluator (OCMath.c):**
```c
#include <complex.h>

double complex ComplexNodeEvaluate(ComplexNodeRef node) {
    // ... other cases ...
    if (nodeType == 'F') {
        double complex arg = ComplexNodeEvaluate(func->left);
        switch (func->funcType) {
            case BM_sqrt:  return csqrt(arg);
            case BM_conj:  return conj(arg);
            case BM_creal: return creal(arg) + 0.0*I;
            case BM_cimag: return cimag(arg) * I;
            case BM_carg:  return cargument(arg) + 0.0*I;
            // ... other functions ...
        }
    }
    // ...
}
```

Validation Steps
----------------
1. Rebuild and run `make clean && make test`.
2. Confirm `conj(sqrt(9+16*I))` now passes.
3. Verify other nested functions (e.g., `sin(cos(0))`, `exp(log(5+2*I))`, `conj(conj(3+4*I))`) still evaluate correctly.
4. Ensure no regressions in arithmetic (unary minus, exponentiation, absolute value) or string tests.

This patch corrects AST construction for nested calls and adds missing evaluation cases, resolving the test failure without breaking existing functionality.
